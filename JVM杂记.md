# 类文件结构

JVM可以理解的代码叫做**字节码**（即扩展名为.class的文件），字节码不面向任何特定的处理器，只面向虚拟机。

字节码的作用：

1. 一定程度上解决了传统解释性语言执行效率低的问题
2. 保留率了解释性语言可移植的特点
3. Java程序无需重新编译便可以在多种不同操作系统的计算机上运行

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktop%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88.png)

字节码文件是不同语言和JVM之间的桥梁，也是Java跨平台的原因之一。



### Class文件结构

根据JVM规范，类文件由单个ClassFile结构组成：

![image-20210817232238393](D:\MyGitHouse\Notes\JVM杂记.assets\image-20210817232238393.png)

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png)



#### 魔数

确定这个文件是否为一个能被JVM接收的Class文件



#### Class文件版本

分主版本号和次版本号。高版本的JVM可以执行低版本编译器生成的Class文件，低版本的JVM不能执行高版本编译器生成的Class文件。所以实际开发时要确保开发的JDK版本和生产环境的JDK版本保持一致。



#### 常量池

常量池主要存放两大常量：**字面量**和**符号引用**

字面量比较接近于Java语言层面常量的概念，如：文本字符串、声明为final的常量值等。

符号引用属于编译原理方面的概念，包括：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符



#### 访问标志

用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是public或者是abstract等



#### 当前类索引，父类索引，接口索引集合

当前类索引用于确定该类的全限定名

父类索引用于确定父类的全限定名

接口索引集合用于描述这个类实现了哪些接口



#### 字段表集合

用于描述接口或类中声明的变量，包括类变量和实例变量，不包括方法内声明的局部变量

![image-20210817234022147](D:\MyGitHouse\Notes\JVM杂记.assets\image-20210817234022147.png)



#### 方法表集合

Class文件中对方法的描述和对字段的描述几乎一致，包含访问标志、名称索引、描述符索引、属性表集合等内容

![image-20210817234056071](D:\MyGitHouse\Notes\JVM杂记.assets\image-20210817234056071.png)



#### 属性表集合

字段表、方法表都可以携带自己的属性表集合，用于描述某些场景专有的信息。



# 类加载过程

Class文件需要加载到JVM之后才能运行和使用。

JVM加载Class文件主要分三步：

**加载 => 连接（验证 => 准备 => 解析） => 初始化**

### 加载

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口

### 验证

1. **文件格式验证**：验证字节流是否符合Class文件格式规范
2. **元数据验证**：对字节码描述的信息进行语义分析，以保证信息符合Java语言规范的要求。如：该类是否有父类、是否继承了不允许被继承的类
3. **字节码验证**：通过数据流和控制流分析，确定程序的语义是合法且符合逻辑的
4. **符号引用验证**：确保解析动作能正确地执行

### 准备

为类变量分配内存，并设置列变量初始值。内存分配将在方法区进行。

1. 内存分配对象向仅包括类变量，实例变量会在类实例化时随着对象一起分配在堆中
2. 即使在代码中定义了类变量的初始值，在这一阶段类变量的初始值仍然是数据类型的默认值，而不是我们定义的值，除非该类变量用final修饰。如：我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字`public static final int value=111` ，那么准备阶段 value 的值就被复制为 111

### 解析

JVM将常量池内的**符号引用**替换成**直接引用**，得到类或者字段、方法在内存中的指针或偏移量。

该动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用限定符等符号引用进行。

符号引用是一组描述目标的符号，可以是任何字面量。

直接引用是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

### 初始化

类加载的最后一步，执行类中定义的Java程序代码（静态），即是执行类构造器<clinit>() 方法的过程。

<clinit>() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。



# 类加载器

所有的非数组类都由**类加载器（ClassLoader）**加载，加载的作用就是将.class文件加载到内存。

数组类型不同过类加载器加载，由JVM直接创建。

### JVM内置的三个ClassLoader 

1. **BootstrapClassLoader**：启动类加载器，由C++实现，负责加载 `%JAVA_HOME%/lib`目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader**：扩展类加载器，主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。
3. **AppClassLoader**：应用程序类加载器，面向用户的加载器，负责加载当前应用classpath下的所有jar包和类。

除BootstrapClassLoader之外，其他的类加载器均由Java实现并继承自java.lang.ClassLoader，如果我们要定义自己的类加载器，也需要继承ClassLoader



### 双亲委派模型

每一个类都有一个对应的类加载器，系统中ClassLoader默认采用**双亲委派模型**来进行协同工作。

所谓双亲委派模型，即在类加载的时候，系统会首先判断当前类是否被加载过，已加载的类会直接返回，否则才会尝试加载。在加载时，首先会把请求委派给父类加载器处理，因此所有加载请求都会传送到顶层的BootstrapClassLoader中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用BootstrapClassLoader来作为父类加载器。

**双亲委派模型中的父子关系并非继承关系，而是采用组合关系来复用父类加载器的相关代码。**

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png)

![img](https://upload-images.jianshu.io/upload_images/5982616-aad63782162c9ae5.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

#### 双亲委派模型的好处

1. 避免类的重复加载：JVM区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类。
2. 保证了Java核心API不被篡改。
   1. 假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改

#### 双亲委派模型的弊端

委派过程是单向的，顶层ClassLoader无法访问底层ClassLoader所加载的类。

在系统类中提供了一个接口， 该接口需要在应用类中得以实现，该接口还绑定一个工厂方法， 用于创建该接口的实例， 而接口和工厂方法都在启动类加载器中。这时，工厂方法就无法创建由应用类加载器加载的类的实例。



#### 如何破坏双亲委派模型

自定义类加载器，重写loadClass()方法



# JVM垃圾回收

Java的自动内存管理主要是针对对象内存的分配与回收，核心是**堆内存**中对象空间的分配与回收。

Java堆又被称为GC堆（Garbage Collected Heap），是垃圾收集器管理的主要区域。从分代垃圾收集算法的角度而言，Java堆可以分为**新生代（Eden、From Survivor、To Survivor）**和**老年代（Tenured）**

## 垃圾回收过程：

1. 新对象一般会被分配在Eden区（大对象，如长度较大的数组或字符串会直接进入Tenured区）
2. 当Eden区空间不足时，会发起一次Minor GC，在这次GC下存活下来的对象进入To Survivor区，From Survivor区中年龄足够大的对象进入Tenured区，其他的则进入To Survivor区
3. 清空Eden区和From Survivor区，然后交换From Survivor区和To Survivor区，使存活的对象均位于From Survivor区，保持To Survivor区为空
4. 重复以上过程，直到To Survivor区被填满（To Survivor区不足以存放Eden和From Survivor区存活的对象时），所有存活的对象移动到Tenured区
5. 当Tenured区空间不足时触发Full GC (Major GC)

在一次GC中对象能否存活由**对象存活判定算法**决定。

对象的在各区域之间的移动由**垃圾回收算法**决定。

## 对象存活判定算法

#### 1、引用计数法

给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；当计数器值为0时对象就是不可再被使用的，即可回收的。

缺陷：难以解决对象之间互相循环引用的问题

#### 2、可达性分析法

以一系列被称之为「GC Root」的对象为起点，自上而下搜索，走过的路径称为引用链，如果一个对象到GC Root没有任何引用链相连时，则证明此对象是不可用的。

![img](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/72762049.jpg)

可作为GC Root的对象：

1. 虚拟机栈中引用的对象
2. 本地方法栈中Native方法引用的对象
3. 方法区中类静态属性引用的对象
4. 方法区中常量引用的对象

在可达性分析算法中被判定为不可达的对象，还要经过两次判断过程才会宣判“死刑”：

1. 判断对象是否有必要执行``finalize()``方法
2. 若有必要执行``finalize()``方法，如果对象在该方法中能重新与引用链上任何一个对象建立关联，则会被移出“即将回收”的集合



#### 四种类型的引用

1. 强引用（StrongReference）

   1. 具有强引用的对象不会被GC
   2. 即使内存空间不足，JVM宁可抛出``OutOfMemoryError``也不会回收具有强引用的对象
   3. 最普遍使用的引用

2. 软引用（SoftReference）

   1. 只具有软引用的对象，会在内存空间不足时被GC，如果回收之后内存仍然不足，JVM才会抛出OOM
   2. 一般用于描述有用但非必需的对象，如实现内存敏感的高速缓存
   3. 可以加速JVM的GC速度，可以维护系统运行安全，防止OOM等问题

3. 弱引用（WeakReference）

   1. 只被弱引用关联的对象，无论内存是否充足都会被GC
   2. 比软引用更弱，常用于描述非必须对象

4. 虚引用（PhantomReference）

   1. 仅持有虚引用的对象，任何时候都可能被GC
   2. 常用于跟踪对象被GC回收的活动

   

## 垃圾回收算法

新生代 => 大批对象死去，少量存活 => 复制算法 => 复制少量存活对象即可

老年代 => 对象存活率高 => 标记-清理算法、标记-整理算法 => 只需标记少量回收对象即可

#### 复制算法

把可用内存按照容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用尽时，把存活的对象复制到另一块内存上，再将这一块内存空间全部清理。

优点：每次都是针对整块内存进行回收，无需考虑内存碎片等复杂的情况，

缺点：每次可使用的内存缩小为原来的一半，内存使用率低。

#### 标记-清除算法

标记出所有需要回收的对象，然后统一清除所有标记的对象

缺点：效率不高；空间碎片多，产生大量不连续的内存碎片，导致后续需要分配较大对象时，因无法找到足够的连续内存而提前出发GC

#### 标记-整理算法

标记出所有需要回收的对象，进行整理，使存活的对象都向一端移动，最后直接清理掉端边界以外的内存

优点：不会浪费空间，也不会产生空间碎片，老年代一般选用该算法



# JVM内存区域划分

JVM提供了自动内存管理机制，所以Java不需要想C/C++那样手动释放内存，不易出现内存泄漏和内存溢出的问题。

#### JDK 1.8之前的JVM内存区域划分

1. **运行时数据区**
   1. **线程共享**的部分：
      1. 堆
      2. 方法区
   2. **线程私有**的部分：
      1. 虚拟机栈
      2. 本地方法栈
      3. 程序计数器
2. **直接内存**（线程共享）

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)



#### JDK 1.8之后的JVM内存区域划分

1. **运行时数据区**
   1. **线程共享**的部分
      1. 堆
   2. **线程私有**的部分
      1. 虚拟机栈
      2. 本地方法栈
      3. 程序计数器
2. **直接内存**（线程共享）
   1. 元空间

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png)



## 程序计数器

当前线程所执行的字节码文件的行号指示器，字节码解释器通过改变计数器的值来决定下一条需要执行的字节码指令。

为保证线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，用于记录当前线程执行的位置。

程序计数器是唯一一个不会出现OOM的内存区域，随线程的创建而创建，随线程的结束而释放。



## Java虚拟机栈

JVM栈描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的，是线程私有的。

JVM栈由一个个栈帧组成，每个栈帧都拥有：局部变量表（存放编译器可知的各种数据类型和对象引用）、操作数栈、动态链接、方法出口等信息。

每一次方法的调用都会有一个对应的栈帧被压入栈，方法调用结束后栈帧弹出并释放栈帧空间。

##### JVM栈可能出现的两种异常：

* **StackOverFlowError** ：当前线程请求栈深度超过当前JVM栈最大深度时抛出。
* **OutOfMemoryError** ：线程请求栈时内存用完且无法扩展时抛出



## 本地方法栈

与JVM栈类似，不同的是本地方法栈为JVM用到的Native方法服务。



## 堆

JVM所管理的内存中最大的一部分，所有线程共享，JVM启动时创建。

专门用于存放对象实例，几乎所有**对象实例**以及**数组**都在Heap中分配内存。

一般分为：新生代、老年代、永生代三部分。

JDK 1.8之后的**方法区**（永久代）被彻底移除，取而代之的是**元空间**，使用直接内存。



## 方法区

线程共享，用于存储已被JVM加载的类信息、常量、静态变量等数据。

JVM规范把方法区描述为堆的一个逻辑部分。

方法区也被称为永久代：JVM规范只是规定了方法区的概念和作用，不同的JVM对方法区的实现是不同的，永久代是HotSpot虚拟机对方法区的一种实现方式。即永久代是HotSpot的概念，其他虚拟机中并没有永久代的概念。



#### 为什么要将方法区替换为元空间？

原因之一：方法区大小有一个固定的上限，无法调整；元空间使用直接内存，根据运行时应用程序需求动态地调整大小。



## 运行时常量池

运行时常量池是方法区的一部分（JDK 1.7之后已经将运行时常量池从方法区移出放入heap中）

常量池包含**字面量**和**符号引用**两部分。

![img](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-14/26038433.jpg)







